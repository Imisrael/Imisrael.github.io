[
{
	"uri": "/3/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction Introduction to GridDB\n"
},
{
	"uri": "/3/getting-started/2-1_system-requirements/",
	"title": "System Requirements",
	"tags": [],
	"description": "",
	"content": " Checking the Required Resources GridDB is a scale-out database that \u0026ndash; unlike a conventional database \u0026ndash; pre-planning of the system design and sizing is not required in order to achieve non-stop operation. However, the following points should be considered as guidelines in the initial system design:\n Memory usage Number of nodes in a cluster Disk usage  The estimation method is explained in sequence below.\nFunctions to increase the capacity by using external storage devices such as SSDs, etc. have not been considered in calculating the memory size below. Please check with our service desk for estimation if these functions are used.\nTotal memory usage 1. Predict the amount of data to be stored in the application. Estimate the following:\n Data size of row Number of rows to be registered  2. Estimate the memory required to store those estimated data.\nMemory capacity used = row data size × no. of registered rows ÷ 0.75 + 8 × no. of registered rows × (assigned index number + 2) ÷ 0.66 (byte)\n3. Perform a similar estimation for all collections created and used in the application. The total sum becomes the amount of memory required in the GridDB cluster.\nTotal memory usage = the sum of memory usage in all collections\nNote: please consider this number as the minimum requirement, as the memory usage also depends on update frequency.\nNumber of Nodes Constituting a Cluster Estimate the required no. of nodes used in GridDB. In the example below, it is assumed that one node is executed in one machine.\nFirst, make an assumption of the memory required per machine.\nIn addition, make an assumption of the no. of replicas to create. The no. of replicas is given as a GridDB configuration value.\nDisk Usage Estimate the size of the file to be created in GridDB, and the disk capacity required for the machine to execute a node. Two types of files should be created; a checkpoint file and a transaction log file.\nThe memory usage of individual node is determined as follows:\nIndividual memory usage = (total memory usage * no. of replicas) ÷ no. of nodes (byte)\nThe size of the checkpoint file is estimated as follows based on this numerical value.\nFile size = Individual memory usage * 2 (byte)\nIn addition, as the transaction log life size is dependent on the update frequency of the application, the following data is thus predicted.\nRow update frequency (times/sec)\nFurthermore, the checkpoint interval is assumed. The checkpoint interval is given as a GridDB configuration value.\n Checkpoint interval  The default value of the checkpoint interval is 1200 sec (20 minutes).\nThe transaction log file size is estimated as follows based on these numerical values:\nFile size = row data size * row update frequency * checkpoint interval (byte)\nThe individual disk usage is estimated as follows.\nIndividual disk usage = Transaction log file size + checkpoint file size\n[Point to note]\nThe size of the checkpoint file expands depending on the data capacity. However, please note that once it has expanded, the file size will not be reduced, even if some of data in the container or row gets deleted. Empty space can be re-used after data is deleted.\n"
},
{
	"uri": "/3/introduction/1-1_what-is-griddb/",
	"title": "What is GridDB",
	"tags": [],
	"description": "",
	"content": " Toshiba GridDB™ is a highly scalable NoSQL database best suited for IoT and Big Data We live in the era of the Internet of Things (IoT) where billions of devices are interconnected and are generating petabytes of data at an increasing rate. Gaining insights and information from that data and generating value out of it gives a tangible competitive advantage to businesses, organizations, governments, and even individuals.\nOrganizations should focus more on creating value from data that will enhance their core products, services or even operational processes rather than spend time in dealing with the complexity surrounding Big Data. Big data, in this case, means data in large quantities, high frequencies, and vast varieties.\nGridDB is an innovative solution built in Toshiba to solve these complex problems. The foundation of GridDB’s principles is based upon offering a versatile data store that is optimized for IoT, provides high scalability, is tuned for high performance, and ensures high reliability.\nFour Pillars of GridDB  Optimized for IoT High Performance High Scalability High Reliability/Availability  1. Optimized for IoT GridDB’s Key Container data model and Time Series functions are built for IoT The Key Container data model of GridDB extends the typical NoSQL Key-Value store. The Key Container model represents data in the form of collections that are referenced by keys. The key and container are rough equivalents of the table name and table data in Relational Databases (RDB). Data modeling in GridDB is easier than with other NoSQL databases as we can define the schema and design the data similar to that of an RDB.\nThe Key Container model allows high speed access to data through Java and C APIs. Data in GridDB is also queried through TQL, a custom SQL-like query language. Basic search through the WHERE command and high speed conditional search operations through indexing offer a great advantage for applications that rely on faster search. GridDB supports transactions, including those with plural records from the application. Transactions in GridDB guarantee ACID (Atomicity, Consistency, Isolation, and Durability) at the container level.\nTwo types of containers are prominent in GridDB: Collection-Container, a general-purpose container; and TimeSeries-Container which is for managing time series data.\nTimeSeries-Container is apt for IoT scenarios where the data is associated with a time-stamp. GridDB supports numerous time-series functions such as\n Data compression, for ever-increasing time series data. This functionality reduces memory usage significantly compared to other DBMS Term release, to automatically delete records that are no longer valid or needed Time series data aggregation and sampling functions  2. High Performance GridDB’s hybrid composition of In-Memory and Disk architecture is designed for maximum performance I/O is a common bottleneck in any DBMS that can cause the CPU to be under-utilized. GridDB overcomes this bottleneck with the ‘Memory first, Storage second’ structure where the ‘primary’ data that is frequently accessed resides in memory and the rest is passed on to disks (SSD and HDD). High performance is achieved in GridDB by:\nPrioritizing In-Memory processing – In scenarios with large amounts of data, GridDB localizes the data access needed by applications by placing as much ‘primary’ data in the same block as possible. Based on the application’s access pattern and frequency GridDB efficiently utilizes memory space by setting hint memory intensity function and thus reduces memory misses.\nReducing the Overhead – Operational and communication overhead occurs in multi-threaded operations due to lock and synchronization. GridDB eliminates this by allocating an exclusive memory and DB file to each CPU core / thread. As a result, execution time gets shortened and better performance is achieved.\nParallel Processing – GridDB achieves high performance through parallel processing within a node and across nodes. Parallel processing across nodes is done by distributing a large dataset among multiple nodes (partitioning). Parallelism is made possible by the event-driven engine which processes multiple requests using the least amount of resources.\n3. High Scalability GridDB scales linearly and horizontally on commodity hardware maintaining excellent performance Traditional RDBMS are built on Scale-Up architecture (add more capacity to existing server/node). Transactions and data consistency are excellent on RDBMS. On the other hand, NoSQL databases focus on Scale-Out architecture (add smaller nodes to form a large cluster) but fair poorly on transactions and data consistency.\nGridDB scales out horizontally with commodity hardware maintaining the same level of performance. Contrary to other scale-out NoSQL databases, GridDB offers strong data consistency at the container level and provides ACID transaction guarantees similar to that of an RDB. Proprietary algorithms of GridDB allow nodes to be added on the fly online without having to stop the service or operation. GridDB offers a dual advantage for businesses that need a scale-out database for large amounts of data but still want to maintain data consistency.\n4. High Reliability/Availability Hybrid cluster management and high fault-tolerant system of GridDB is exceptional for mission-critical applications Network partitions, node failures, and maintaining consistency are some of the major problems that arise when data is distributed across nodes. Typically, distributed systems adopt ‘Master-Slave’ or ‘Peer-to-Peer’ architectures. Master-Slave option is good at maintaining data consistency but a master node redundancy is required to avoid having a Single Point of Failure (SPOF). Peer-to-Peer, though avoids SPOF, has a huge problem of communication overhead among the nodes.\nGridDB’s autonomous control cluster architecture integrates the advantages of and overcomes the disadvantages of both Master-Slave and Peer-to-Peer styles. GridDB’s algorithms select the master node automatically among peers, and, in case of master node failure, operations remain intact as a new master is appointed automatically and immediately. GridDB’s proprietary algorithms avoid the classic distributed computing problem of Split-Brain, which occurs due to cluster partition during network failures. GridDB also offers various levels of replication based on the availability requirements of the application.\nOverall, GridDB offers multiple reliability features for mission-critical applications that require high availability and data retention.\nAnd finally\u0026hellip;\nWhen it comes to IoT and Big Data use-cases, GridDB clearly stands out among other databases in the Relational and NoSQL space. Toshiba’s customers in various industry verticals have successfully implemented IoT projects by harnessing the power of GridDB. For more detailed information on each topic covered above, business use-cases and implementation, benchmark performance results and many more please check the GridDB website www.griddb.org\n"
},
{
	"uri": "/3/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Getting Started Quickstart\n"
},
{
	"uri": "/3/introduction/1-2_griddb-edition/",
	"title": "GridDB Editions",
	"tags": [],
	"description": "",
	"content": " There are currently two distinct versions of GridDB available. The information below is designed to help distinguish between the editions and help users arrive to the correct choice for their situation.\nGridDB Community Edition (GridDB CE) GridDB CE is available under the AGPLv3 as a high-performant, open-source NoSQL database built with scalability and fault tolerance in-mind. This is the only edition of GridDB that is open-source.\nGridDB Standard Edition (GridDB SE) A high-performant commerical NoSQL database. Included with the commercial license are tools, features, and the software support needed for critical big data applications.\nComparison of each edition are as follows:\n | | GridDB Community Edition | GridDB Standard Edition | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-| | SOFTWARE SUPPORT | | | | Maintenance Releases | X | O | | Bug fixes/Patches | X | O | | Updates | X | O | | BASIC | | | | Distributed Data Management | O | O | | Transaction Management | O | O | | DATA TYPE SUPPORT | | | | Key-value data | O | O | | Time-series data | O | O | | Geometry data | X | O | | QUERY LANGUAGE | | | | SQL Subset (TQL) | O | O | | SCALABILITY | | | | Offline expansion | O | O | | Online expansion | X | O | | PERSISTENCY | | | | In-Memory and Disk | O | O | | API | | | | Java | O | O | | C | O | O | | ADMINISTRATIVE TOOL | | | | Offline backup | O | O | | Online backup | X | O | | Export/import | X | O | | Differential backup function | X | O | | Management GUI | X | O | | Status Acquisition | O | O |\nLicense Types\nSubscription License: A license that can only be used during the contract period service\n"
},
{
	"uri": "/3/getting-started/2-2_installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " The following instructions are for the Standard Edition of GridDB. Instructions for the Community Edition can be found below\nSetup This chapter explains the installation of a node onto a single machine. See the chapter on operations for the cluster configuration.\n// The lsb_release command prints certain LSB (Linux Standard Base) and Distribution information. $ lsb_release -id Distributor ID: CentOS Description: CentOS release 6.3 (Final)   Installing a Node\nThe following 3 RPM packages are needed when installing a GridDB node. Place these packages anywhere in the machine.\n     Package name File name Description     griddb-server griddb-server-X.X.X-linux.x86_64.rpm The start and other commands for the GridDB node module and server are included.   griddb-client griddb-client-X.X.X-linux.x86_64.rpm One set of operating commands except start node is included.   griddb-docs griddb-docs-X.X.X-linux.x86_64.rpm GridDB manual and program samples are included.    *X.X.X is the GridDB version\nInstall using the rpm command as a root user.\n$ su \\# rpm -Uvh griddb-server-X.X.X-linux.x86_64.rpm Under preparation... ########################################### \\[100%\\] User gsadm and group gridstore have been registered. GridStore uses new user and group. 1:griddb-server ########################################### \\[100%\\] \\# rpm -Uvh griddb-client-X.X.X-linux.x86_64.rpm Under preparation... ########################################### \\[100%\\] User and group has already been registered correctly. GridStore uses existing user and group. 1:griddb-client ########################################### \\[100%\\] \\# rpm -Uvh griddb-docs-X.X.X-linux.x86_64.rpm Under preparation... ########################################### \\[100%\\] 1:griddb-docs ########################################### \\[100%\\]  When you install the package, the following group and user are created in the OS. This OS user is set as the operator of GridDB.\n   Group User Home directory     gridstore gsadm /var/lib/gridstore    The following environment variables are defined in this gsadm user.\n   Environment variables Value Meaning     GS_HOME /var/lib/gridstore gsadm/GridDB home directory   GS_LOG /var/lib/gridstore/log Event log file output directory    [Points to note]\n These environment variables are used in the operating commands described later. The password of the gsadm user has not been set. With the root user privilege, please set the password appropriately.  Some of the functions of the operation tools may be necessary.   In addition, when the GridDB node module is installed, services that are executed automatically upon startup of the OS will be registered.\n   Service Name Run Level     gridstore 3, 4, 5    The service registration data can be checked with the following command.\n# /sbin/chkconfig \u0026ndash;list | grep gridstore gridstore 0:off 1:off 2:off 3:on 4:on 5:on 6:off\nThe GridDB node will be started automatically by this service during OS startup.\n[Points to note]\n Services will not start automatically immediately after installation.  To Stop auto startup of a service, use the command below.\n# /sbin/chkconfig gridstore off\nSee the chapter on services in \u0026lsquo;GridDB Operational Management Guide\u0026rsquo; (GridDB_OperationGuide.html) for details of the services.\nPost-Installation Checks\nCheck the directory configuration of the installed GridDB node.\nFirst, check that the GridDB home directory, and related directory and files have been created.\nGridDB home directory /var/lib/gridstore/ # GridDB home directory admin/ # integrated operational management GUI home directory backup/ # backup directory conf/ # definition file directory gs_cluster.json # cluster definition file gs_node.json # node definition file password # user definition file data/ # database file directory log/ # log directory  Confirm the following command.\n$ ls /var/lib/gridstore/ admin backup conf data log  Next, check that the installation directory has been created.\nInstallation directory /usr/gridstore-X.X.X/ # installation directory Fixlist.pdf # revision record Readme.txt # release instructions bin/ # operation command, module directory conf/ # definition file sample directory docs/ # document directory etc/ lib/ # library directory license/ # license directory prop/ # configuration file directory web/ # integrated operational management GUI file directory  Confirm with the following command.\n$ ls /usr/gridstore-X.X.X/ Fixlist.pdf Readme.txt bin conf etc lib license prop web  All documents have been compressed into a single ZIP file. Decompress and refer to the documents where appropriate as shown below.\n$ cd /usr/gridstore-X.X.X/docs $ unzip griddb-documents-X.X.X.zip  In addition, the following symbolic links are created as shown below in a few directories under the installation directory for greater convenience.\n$ ls /usr/gridstore/ conf lib prop web  Lastly, confirm the version of the server module installed with the following command.\n$ gsserver --version GridDB version X.X.X build XXXXX  [Points to note]\nThe following files are created when GridDB is operated according to the following procedure.\n[Database file]\n/var/lib/gridstore/ # GridDB home directory data/ # database file directory gs\\_log\\_n_m.log # log file to record the transaction logs (n, m are numbers) gs\\_cp\\_n_p.dat # checkpoint file to record data regularly (n, p are numbers)  [Log file]\n/var/lib/gridstore/ # GridDB home directory log/ # log directory gridstore-%Y%m%d-n.log # event log file gs_XXXX.log # operation tool log file  The directory where these files are created can be changed by the parameter settings in the node definition file.\n*gs_XXXX is an operation tool name. (Example: gs_startnode.log)\nSetting Up an Administrator User\nAdministrator privilege is used for authentication related matter within the nodes and clusters. Creation date of administrator user is saved in the user definition file. The default file is as shown below.\n /var/lib/gridstore/conf/password  The default user below exists immediately after installation.\n   User Password Example of proper use     admin admin For authentication of operation administrator user, operation commands   system manager For authentication of application user, client execution    Administrator user information including the above-mentioned default users can be changed using the user administration command in the operating commands.\n   Command Function     gs_adduser Add an administrator user   gs_deluser Delete an administrator user   gs_passwd Change the password of administrator user    Change the password as shown below when using a default user. The password is encrypted during registration.\n$ gs_passwd admin Password: (enter password) Retype password: (re-enter password)  [Points to note]\n A GridDB administrator user is different from the OS user gsadm created during installation. A change in the administrator user information using a user administration command becomes valid when a node is restarted. In order to use it for authentication purposes in the client, the same user data needs to be registered in all the nodes. Copy the user definition file and make sure the same user data can be referred to in all the nodes. Execute the operating command as a gsadm user.  [Memo]\n See “GridDB Operational Management Guide” (GridDB_OperationGuide.html) for details of the user management commands.  Installation (Community Editon) on a Singular Node This section will layout the steps to installing GridDB. These instructions have been confirmed to work on CentOS version 6.7. First, download the GridDB RPM: here. Switch to the root user and install the RPM by using the “rpm” command:\n$ su \\# rpm -ivh griddb\\_nosql-X.X.X-linux.x86\\_64.rpm Preparing... ########################################### \\[100%\\] Information: User gsadm and group gridstore have been registered. GridDB uses new user and group. 1:griddb_nosql ########################################### \\[100%\\] ```\t### Confirmation After Installation After installing GridDB's node module, the user “gsadm” and the group “gridstore” are created. Use the user and group for running a node module and operational commands. And please note that a password for the new user gsadm is not automatically set upon creation, so please take the time to set one. If installation completed normally, the following directories and files are created as well as necessary modules and commands.  /var/lib/gridstore/ # GridDB home directory backup/ # Backup directory(unused) conf/ # Directory storing definition files gs_cluster.json # Cluster definition file gs_node.json # Node definition file password # User definition file data/ # Directory storing database files log/ # Directory storing event log files\n We should also confirm that the following files and directories exist:  $ ls /var/lib/gridstore/* /var/lib/gridstore/backup:\n/var/lib/gridstore/conf: gs_cluster.json gs_node.json password\n/var/lib/gridstore/data:\n/var/lib/gridstore/log:\n Confirm the directory structure of the installed GridDB client libraries. If installation completed normally, the following files are created.  $ ls -l /usr/share/java/*gridstore* lrwxrwxrwx 1 gsadm gridstore 46 Apr 11 20:43 /usr/share/java/gridstore-conf.jar -\u0026gt; /usr/griddb-X.X.X/bin/gridstore-conf-X.X.X.jar lrwxrwxrwx 1 gsadm gridstore 41 Apr 11 20:43 /usr/share/java/gridstore.jar -\u0026gt; /usr/griddb-X.X.X/bin/gridstore-X.X.X.jar\n If you start a GridDB node and then access and run the node from a client, the following files are created in the directories to store database files and event log files.  /var/lib/gridstore/ # GridDB home directory data/ # Directory storing database files gs_log_n_m.log # File recording transaction logs (n, m: positive number) gs_cp_n_p.dat # Checkpoint file recording data regularly (n, p: positive number)\n The event log file will be in the following location  /var/lib/gridstore/ # GridDB home directory log/ # Directory storing event logs gridstore-%Y%m%d-n.log # Event log file\n ### Setting up an Administrator User After all of this, you must create an administrator user to use GridDB. The administrator user information is stored in the User Definition file. The default file is as shown here: $GS\\_HOME/conf/password. After installation a default user called “admin” will be created. The operating commands used to change the default users’ information are shown below. | Command | Function | |------------|----------------------------------------------| | gs_adduser | Add an administrator user | | gs_deluser | Delete an administrator user | | gs_passwd | Change the password of an administrator user | It is recommended that you add a password to the user “admin” as one is not set upon creation.  $ gs_passwd admin Password:（Input password） Retype password:（Input password again）\nIf you’d like to add another user beyond the default “admin” user, it must start with “gs#”  $ gs_adduser gs#newuser Password:（Input password） Retype password:（Input password again） ``` Once the changes you wanted to make are done, you will need to restart the node for the changes to have effect.\n"
},
{
	"uri": "/3/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/3/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/3/",
	"title": "Version 3.0",
	"tags": [],
	"description": "",
	"content": ""
}]